\chapter{Related Work}

The following are current practices
shown on the topic,
how best to model different deployment environments with GitOps.


\section{branch-per-environment approach}

\citeauthor{codefreshStopUsingBranchesGitOpsEnvironments} (\citeyear{codefreshStopUsingBranchesGitOpsEnvironments})
published Codefresh's best practices on modeling environments in GitOps 
in the blog post "Stop Using Branches for Deploying to Different GitOps Environments".
The problems with the branch-per-environment approach are shown.
This approach is an anti-pattern,
and to be avoided at all costs.
A number of points are made and justified in detail.

\begin{itemize}
	\item Using different Git branches for deployment environments is a relic of the past.
	\item Pull requests and merges between different branches is problematic.
	\item People are tempted to include environment specific code and create configuration drift.
	\item As soon as you have a large number of environments, maintenance of all environments gets quickly out of hand.
	\item The branch-per-environment model goes against the existing Kubernetes ecosystem.
\end{itemize}

\noindent
\autocite{codefreshStopUsingBranchesGitOpsEnvironments}

\section{folder-per-environment approach}

\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
provides some best practices from Codefresh on the problem in the blog post: "How to Model Your Gitops Environments and Promote Releases Between Them."
%\bigskip
%
%\noindent
Es werden folgende Kategorien der "Umgebungskonfiguration" vorgeschlagen:

\begin{itemize}
    \item \textbf{Application version} in the form of the container tag used. This is the setting that increases with each release and decreases with each rollback - and is always promoted between environments.
	\item \textbf{Kubernetes-specific settings} for the application (manifests).
	\item \textbf{Mainly static settings} for the business logic. These include external URLs, internal queue sizes, UI default values, authentication profiles, etc. By "mostly static" they mean settings that are defined once for each environment and then generally do not change. These settings should never be promoted between environments.
	\item \textbf{Non-Static Business Settings}. This is the same as the previous item, but it includes settings that are indeed promoted between environments. These can be a global VAT setting, parameters for the recommendation engine, the available bitrate encodings, and any other setting that is specific to the business or enterprise.
\end{itemize}

\noindent
\autocite{codefreshHowToModelGitOpsEnvironmentsAndPromote}
\bigskip

\noindent
The application version and non-static business settings are promoted between environments.
\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
suggests defining the configuration parameters per category in a separate file.
As a result, the four categories can be promoted independently.
The folder-per-environment approach is proposed.
% TODO: visuell darstellen die 4 config files ?
In general, all promotions are just copy operations. 
Unlike the branch-per-environment approach, with the folder-per-environment approach 
everything can be moved from any environment to any other environment
without fear that the wrong changes will be applied. 
Especially when it comes to backporting configurations, the folder-per-environment approach shines, 
because configurations can be easily moved both "forward" and "backward", 
even between unrelated environments.
\bigskip

\noindent
\textbf{Scenario}: Promotion of the application version from qa to staging-us.

\begin{verbatim}
	cp envs/qa/version.yml envs/staging-us/version.yml
\end{verbatim}

\noindent
\textbf{Scenario}: Promotion of the application from prod-eu to prod-us together with the additional configuration. The settings file(s) are also copied.

\begin{verbatim}
	cp envs/prod-eu/version.yml envs/prod-us/version.yml
	cp envs/prod-eu/settings.yml envs/prod-us/settings.yml
\end{verbatim}

\noindent
\textbf{Scenario}: Backport all settings from qa to integration-non-gpu.

\begin{verbatim}
	cp envs/qa/settings.yml envs/integration-non-gpu/settings.yml
\end{verbatim}

\noindent
\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
notes,
that the copy operations are for illustrative purposes only. 
In a real-world application, this operation would be performed automatically by a CI system 
or other orchestration tool. And depending on the environment 
perhaps a pull request should be created first instead of processing the folder in the main branch directly
\autocite{codefreshHowToModelGitOpsEnvironmentsAndPromote}.
\bigskip

\noindent
\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
suggests the following advantages of the folder-per-environment approach:

\begin{itemize}
	\item The order of commits in the Git repository is irrelevant. When a file is copied from one folder to the next, the commit history doesn't matter.
	\item If only files are copied, only exactly what is needed is promoted, and nothing else.
	\item No need to use git cherry picks or other advanced git methods to promote releases. Only files need to be copied.
	\item The user is free to commit any change from any environment to any environment, without any restrictions on the proper "order" of environments.
	\item Using diff operations on files, it is easy to track what is different between environments in all directions (both in the source and target environments and vice versa).
\end{itemize}

\noindent
\autocite{codefreshHowToModelGitOpsEnvironmentsAndPromote}

% TODO: Delta zw. Related Work and Your Work? was machst du mehr/besser/schneller/genauer/anders/etc.?







