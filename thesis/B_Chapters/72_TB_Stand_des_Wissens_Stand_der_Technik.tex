\chapter{Stand des Wissens / Stand der Technik}

Im Folgenden werden die derzeitigen Praktiken und Best Practices
gezeigt zum Thema,
wie am besten verschiedene Deployment-Umgebungen mit GitOps modelliert werden.


\section{Branch-per-Environment-Ansatz}

\citeauthor{codefreshStopUsingBranchesGitOpsEnvironments} (\citeyear{codefreshStopUsingBranchesGitOpsEnvironments})
veröffentlicht in einem Blogbeitrag "Stop Using Branches for Deploying to Different GitOps Environments"
die Best Practices von Codefresh zum Thema der Modellierung von Umgebungen in GitOps.
Es werden die Probleme des Branch-per-Environment-Ansatzes gezeigt.
Dieser Ansatz sei ein Anti-Pattern,
und auf jeden Fall zu vermeiden.
Es werden einige Punkte angeführt und ausführlich begründet.

\begin{itemize}
	\item Die Verwendung verschiedener Git-Branches für Deployment-Umgebungen ist ein Relikt der Vergangenheit.
	\item Pull Requests und Merges zwischen verschiedenen Branches sind problematisch.
	\item Die Versuchung ist groß, umgebungsspezifischen Code einzubinden und einen Konfigurationsdrift zu erzeugen.
	\item Sobald man eine große Anzahl an Umgebungen hat, gerät die Wartung aller Umgebungen schnell außer Kontrolle.
	\item Der Branch-per-Environment-Ansatz widerspricht dem bestehenden Kubernetes-Ökosystem.
\end{itemize}


\section{Folder-per-Environment-Ansatz}

\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
liefert in einem Blogbeitrag
"How to Model Your Gitops Environments and Promote Releases between Them"
einige Best Practices von Codefresh zu der Problemstellung.
Codefresh ist die Organisation hinter dem Argo Project
% TODO: cite Argo Project
\autocite{argoProjWebsite},
welches eine Suite an Open-Source-Tools für GitOps
entwickelt
\autocite{codefreshHowToModelGitOpsEnvironmentsAndPromote}.

\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
schlägt vorerst folgende Kategorien der "Umgebungskonfiguration" vor:

\begin{itemize}
    \item \textbf{App-Version} in Form des verwendeten Container-Tags. Das ist jene Einstellung, die sich bei jedem Release erhöht und bei jedem Rollback verringert - und immer zwischen Umgebungen promotet wird.
    \item \textbf{Kubernetes-spezifische Einstellungen} für die Applikation (Manifests).
    \item \textbf{Überwiegend statische Einstellungen} für die Geschäftslogik. Das sind z. B. externe URLs, interne Warteschlangengrößen, UI-Standardwerte, Authentifizierungsprofile usw. Mit "größtenteils statisch" sind Einstellungen gemeint, die einmal für jede Umgebung definiert werden und sich dann in der Regel nicht mehr ändern. Diese Einstellungen sollten niemals zwischen Umgebungen promotet werden.
    \item \textbf{Nicht-statische Geschäftseinstellungen}. Dies ist dasselbe wie der vorige Punkt, aber es umfasst Einstellungen, die sehrwohl zwischen Umgebungen promotet werden. Dabei kann es sich um eine globale Mehrwertsteuer-Einstellung, Parameter für die Empfehlungs-Engine, die verfügbaren Bitraten-Codierungen und jede andere Einstellung handeln, die für das Geschäft bzw. Unternehmen spezifisch ist.
\end{itemize}

Die App-Version und die nicht-statischen Geschäftseinstellungen gehören zwischen Umgebungen promotet.
\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
schlägt vor, die Konfigurationsparameter je Kategorie in einer separaten Datei zu definieren.
Infolgedessen können die vier Kategorien unabhängig voneinander promotet werden.
Es wird der Folder-per-Environment-Ansatz vorgeschlagen.

% TODO: visuell darstellen die 4 config files ?

Im Allgemeinen sind alle Promotions nur Kopiervorgänge. 
Im Gegensatz zum Branch-per-Environment-Ansatz kann beim Folder-per-Environment-Ansatz 
alles von einer beliebigen Umgebung in eine andere Umgebung verschoben werden, 
ohne befürchten zu müssen, dass die falschen Änderungen übernommen werden. 
Besonders wenn es um die Rückportierung von Konfigurationen geht, glänzt Folder-per-Environment-Ansatz, 
da Konfigurationen einfach sowohl "vorwärts" als auch "rückwärts" verschoben werden können, 
sogar zwischen nicht verwandten Umgebungen.
\bigskip

\textbf{Szenario}: Promotion der App-Version von qa zu staging-us.

\begin{verbatim}
	cp envs/qa/version.yml envs/staging-us/version.yml
\end{verbatim}

\textbf{Szenario}: Promotion der Applikation von prod-eu nach prod-us zusammen mit der zusätzlichen Konfiguration. Hier werden auch die Einstellungsdatei(en) kopiert.

\begin{verbatim}
	cp envs/prod-eu/version.yml envs/prod-us/version.yml
	cp envs/prod-eu/settings.yml envs/prod-us/settings.yml
\end{verbatim}

\textbf{Szenario}: Rückportierung aller Einstellungen von qa zu integration-non-gpu.

\begin{verbatim}
	cp envs/qa/settings.yml envs/integration-non-gpu/settings.yml
\end{verbatim}

\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
merkt hierbei an,
dass die cp-Operationen nur zur Veranschaulichung dienen. 
In einer realen Anwendung würde dieser Vorgang automatisch von einem CI-System 
oder einem anderen Orchestrierungswerkzeug durchgeführt werden. Und je nach Umgebung 
sollte vielleicht zuerst ein Pull Request erstellt werden, anstatt den Ordner im Haupt-Branch direkt zu bearbeiten
\autocite{codefreshHowToModelGitOpsEnvironmentsAndPromote}.
\bigskip

\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
nennt folgende Vorteile des Folder-per-Environment-Ansatzes:

\begin{itemize}
	\item Die Reihenfolge der Commits im Git-Repository ist irrelevant. Wenn eine Datei von einem Ordner in den nächsten kopiert wird, ist die Commit-Historie egal.
	\item Wenn lediglich Dateien kopiert werden, wird nur genau das promotet, was gebraucht wird, und sonst nichts.
	\item Es müssen weder Git Cherry-Picks noch andere fortgeschrittene Git-Methoden verwendet werden, um Releases zu promoten. Es müssen lediglich Dateien kopiert werden.
	\item Es steht dem Benutzer frei, eine beliebige Änderung aus einer beliebigen Umgebung in eine beliebige Umgebung zu übernehmen, ohne dass es irgendwelche Einschränkungen bezüglich der richtigen "Reihenfolge" der Umgebungen gibt.
	\item Mit Hilfe von Diff-Operationen auf Dateien ist es leicht nachzuvollziehen, was sich zwischen den Umgebungen in allen Richtungen unterscheidet (sowohl in der Quell- als auch in der Zielumgebung und umgekehrt).
\end{itemize}









