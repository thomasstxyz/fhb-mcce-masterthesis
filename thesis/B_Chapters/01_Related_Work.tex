
\chapter{Related Work}
\label{related-work}

This chapter focuses on the related work by other researchers on the topic.
This includes minimal to none scientific peer-reviewed data,
and a limited amount of blog posts and articles by
organizations involved and actively participating in the GitOps space.

\section{Limited scientific data}

Since the introduction of the term GitOps by
\citeauthor{gitopsOperationsByPullRequest2017Weaveworks} (\citeyear{gitopsOperationsByPullRequest2017Weaveworks})
at Weaveworks,
there has been
insufficient
%limited
scientific literature written about the topic.
The following paragraph highlights prior 
scientific research done on the subject "GitOps",
which has mainly been targeted at
evaluating the concept of GitOps in general.
\bigskip

%as opposed to focusing on new and specific problems that emerge with the adoption of GitOps,
%like the one focused on in this thesis.
%\bigskip

\noindent
\citeauthor{limoncelli_gitopsPathToMoreSelfService} (\citeyear{limoncelli_gitopsPathToMoreSelfService})
draws attention to GitOps in an article, where the concept is brought to the reader in an easily digestible way.
The author clearly highlights the benefits of adoption of GitOps,
however does not mention any negative aspects.
%\citeauthor{whatIsGitOpsSalecha2023} (\citeyear{whatIsGitOpsSalecha2023})
%discusses the definition of the "GitOps"-term
%\autocite{whatIsGitOpsSalecha2023}.
\citeauthor{gitopsTheEvolutionOfDevops9565152} (\citeyear{gitopsTheEvolutionOfDevops9565152})
discuss the idea of GitOps as an evolution of DevOps. They conduct research on the definition of both terms.
\citeauthor{continuousDeploymentIOTEdgeComputingAGitOpsImplementation_9820108} (\citeyear{continuousDeploymentIOTEdgeComputingAGitOpsImplementation_9820108})
publish a conference paper about implementing GitOps in Internet of Things (IoT) Edge Computing
to achieve Continuous Deployment.
They present a proof of concept to check the feasibility of applying GitOps
in IoT Edge Computing solutions.
\citeauthor{analysisOnDeclarativePullBasedDeploymentGitOpsArgoCD_9563984} (\citeyear{analysisOnDeclarativePullBasedDeploymentGitOpsArgoCD_9563984})
present an analysis of declarative and pull-based deployment models
following GitOps principles by using the tool ArgoCD;
and focuses on the advantages compared to push-based deployment models.
\bigskip

\noindent
Hitherto, there have not been any publications
in academic journals or conferences
on the specific topic of
modeling multiple deployment environments with GitOps and promoting releases between them.
However,
%\bigskip
%
%\noindent
\citeauthor{kostisKapelonisMeetACodefresher} (\citeyear{kostisKapelonisMeetACodefresher})
at Codefresh
published a couple of blog posts in recent years,
where some best practices are presented on the topic.
Codefresh is the organization behind the Argo Project \autocite{argoProjWebsite},
and therefore a major driving force in the GitOps ecosystem.
\bigskip

\section{Suggested best practices}

\noindent
%In
%\citetitle{codefreshStopUsingBranchesGitOpsEnvironments}
\citeauthor{codefreshStopUsingBranchesGitOpsEnvironments} (\citeyear{codefreshStopUsingBranchesGitOpsEnvironments})
discusses
the idea of
modeling different deployment environments by using Git branches.
He
explains thoroughly why this approach is an anti-pattern and should not be used
\autocite{codefreshStopUsingBranchesGitOpsEnvironments}.
%In
%\citetitle{codefreshHowToModelGitOpsEnvironmentsAndPromote}
\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
shares
a multitude of suggestions and best practices
about modeling environments and promoting releases between them.
Different environments are modeled by customizing \autocite{kustomizeIoWebsite} configuration 
in separate files and folders or Git repositories.
For promoting between environments, basic file copy operations are suggested.
It is noted, that these simple file copy operations can easily be automated by an external system,
like a CI/CD system.
\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
suggests four categories of environment configuration.
The application version,
Kubernetes specific settings,
mostly static business settings,
and 
non-static business settings.
While the application version and non-static business settings are promoted,
Kubernetes specific settings and mostly static business settings are generally not promoted between environments
\autocite{codefreshHowToModelGitOpsEnvironmentsAndPromote}.
\bigskip

\noindent
In 2021 the
Argo Project \autocite{argoProjWebsite}
presented the
\citetitle{argocdAutopilotWebsite}-tool \autocite{argocdAutopilotWebsite}
to help new GitOps adopters with
structuring their Git repositories,
and
promoting applications between environments.
This command line interface (CLI) tool,
which includes some of the earlier presented best practices,
helps with the initial bootstrap process for ArgoCD.
\bigskip









\section{Related Tools}

This section presents software tools,
which provide similar problem solutions compared to that of
this concrete research.

\subsection*{Weave GitOps Pipelines}
% https://docs.gitops.weave.works/docs/enterprise/pipelines/promoting-applications/

The company Weaveworks,
offer a solution in their enterprise GitOps offering,
to deal with multiple deployment environments.
This functionality is limited to their closed-source Weave GitOps Enterprise offering.
It allows the user to specify an application reference,
which is a Flux HelmRelease resource,
which can be deployed in a Pipeline like way,
through many environments.
Once an environment was successfully delivered with the new version,
it sends a HTTP webhook to the next environment, or the management cluster,
to trigger deployment to the next environment.
The user may configure pull requests to be created for the promotion itself,
which a human may review and approve.
The pipeline allows for the ability to specify, that certain environments need
to pass before a consecutive environment can be deployed to.
Alternatively to promoting via pull requests,
it may be configured to send notifications
to an external system -
which can then promote the application in whatever way
\autocite{weaveGitOpsPipelines}.

\subsection*{akuity/kargo}

As per the website
\enquote*{Kargo is a next-generation continuous delivery (CD) platform for Kubernetes. It builds upon established practices (like GitOps) and existing technology (like Argo CD) to streamline, or even automate, the progressive rollout of changes across multiple environments.}
\autocite{kargoAkuityWebsite}
Kargo is still in very early development by the company Akuity.
The tool is in the form of a Kubernetes custom operator, which provides custom resources
for Environment, Promotion, and PromotionPolicy.
Kargo allows users to define promotion processes in the form of updates of desired state,
which is stored in Git. It supports updating Kubernetes manifests, container images, helm charts,
and ArgoCD Applications, all by updating the desired state in a Git repository.
It offers health checks for ArgoCD Applications to determine a healthy state of a particular environment.
For the promotion process, Kargo commits to Git repositories
\autocite{kargoAkuityWebsite}.

\subsection*{wayfair-incubator/telefonistka}

\enquote*{Telefonistka is a Github webhook server/Bot that facilitates change promotion across environments/failure domains in Infrastructure as Code(IaC) GitOps repos.}
\autocite{telefonistka}
It is designed to sync folders in Git repositories from source paths to target paths.
When it detects changed that are not yet synced,
it will create a pull request against the repository.
It supports any directory structure of users GitOps repositories -
it is unopinionated.
It has drift detection as a feature. It can detect if there are changes in
latter environments, which have not been promoted, i.e. are not in previous environments.
Currently the tool can be run as a GitHub action, or as a
standalone webhook server, preferably as a GitHub Application.
In both cases it supports GitHub as the Git provider
\autocite{telefonistka}.

\subsection*{XenitAB/gitops-promotion}

\enquote*{gitops-promotion interacts with a Git provider to do automatic propagation of container images across a succession of environments.}
\autocite{xenitABgitopsPromotion}
The supported Git providers are GitHub and Azure DevOps.
gitops-promotion is a command line interface program.
It is best suited to be used as part of a CI pipeline/workflow
\autocite{xenitABgitopsPromotion}.

\subsection*{form3tech-oss/k8s-promoter}

The k8s-promoter command line interface tool can promote Kubernetes manifests, by
taking a Git commit range between two or more commits, and applying that to another environment.
For the promotion itself it raises a pull request on GitHub
\autocite{form3techK8sPromoter}.

\section{Summary}
% Schreib einen Absatz, der erkl√§rt, inwieweit deine Arbeit anders ist als Related Work. Arbeite das Delta (den Unterschied) zwischen Related Work vs. Your Work aus und betone nochmal deinen Beitrag zum GitOps-Forschungsfeld (das was du beitragen wirst im Vergleich zu allen anderen)

Prior research on the concrete problem is focused on presenting
best practices and suggestions
which users need to manually implement themselves.
In addition it is suggested to let an external CI/CD system handle the promotion process.
Conversely, this thesis will bring forward
abstract models of environments and promotion processes,
which are implemented in the proposed prototype tooling.
The prototype will assess the feasibility of
defining deployment environments and promotion processes declaratively,
following the GitOps principles.

TODO



























%\section{Scientific Publications}
%
%\subsection{are there any at all?}
%
%
%\section{Codefresh and Argo Project}
%
%\subsection{Argo-CD Autopilot}
%\url{https://argocd-autopilot.readthedocs.io/en/stable/}
%
%
%\section{Honorable Mentions}
%
%\subsection{IBM Cloud Pak - Guide - Promoting across environments}
%\url{https://production-gitops.dev/guides/cp4i/mq/cloud-native/promote-environments/#production-environment}
%
%\section{Summary}






%The following are current practices
%shown on the topic,
%how best to model different deployment environments with GitOps.
%
%
%\section{branch-per-environment approach}
%
%\citeauthor{codefreshStopUsingBranchesGitOpsEnvironments} (\citeyear{codefreshStopUsingBranchesGitOpsEnvironments})
%published Codefresh's best practices on modeling environments in GitOps 
%in the blog post "Stop Using Branches for Deploying to Different GitOps Environments".
%The problems with the branch-per-environment approach are shown.
%This approach is an anti-pattern,
%and to be avoided at all costs.
%A number of points are made and justified in detail.
%
%\begin{itemize}
%	\item Using different Git branches for deployment environments is a relic of the past.
%	\item Pull requests and merges between different branches is problematic.
%	\item People are tempted to include environment specific code and create configuration drift.
%	\item As soon as you have a large number of environments, maintenance of all environments gets quickly out of hand.
%	\item The branch-per-environment model goes against the existing Kubernetes ecosystem.
%\end{itemize}
%
%\noindent
%\autocite{codefreshStopUsingBranchesGitOpsEnvironments}
%
%% immer flie√ütext nach aufz√§hlungen, tabellen, etc.
%
%\section{folder-per-environment approach}
%
%\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
%provides some best practices from Codefresh on the problem in the blog post: "How to Model Your Gitops Environments and Promote Releases Between Them."
%%\bigskip
%%
%%\noindent
%Es werden folgende Kategorien der "Umgebungskonfiguration" vorgeschlagen:
%
%\begin{itemize}
%    \item \textbf{Application version} in the form of the container tag used. This is the setting that increases with each release and decreases with each rollback - and is always promoted between environments.
%	\item \textbf{Kubernetes-specific settings} for the application (manifests).
%	\item \textbf{Mainly static settings} for the business logic. These include external URLs, internal queue sizes, UI default values, authentication profiles, etc. By "mostly static" they mean settings that are defined once for each environment and then generally do not change. These settings should never be promoted between environments.
%	\item \textbf{Non-Static Business Settings}. This is the same as the previous item, but it includes settings that are indeed promoted between environments. These can be a global VAT setting, parameters for the recommendation engine, the available bitrate encodings, and any other setting that is specific to the business or enterprise.
%\end{itemize}
%
%\noindent
%\autocite{codefreshHowToModelGitOpsEnvironmentsAndPromote}
%\bigskip
%
%\noindent
%The application version and non-static business settings are promoted between environments.
%\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
%suggests defining the configuration parameters per category in a separate file.
%As a result, the four categories can be promoted independently.
%The folder-per-environment approach is proposed.
%% visuell darstellen die 4 config files ?
%In general, all promotions are just copy operations. 
%Unlike the branch-per-environment approach, with the folder-per-environment approach 
%everything can be moved from any environment to any other environment
%without fear that the wrong changes will be applied. 
%Especially when it comes to backporting configurations, the folder-per-environment approach shines, 
%because configurations can be easily moved both "forward" and "backward", 
%even between unrelated environments.
%\bigskip
%
%\noindent
%\textbf{Scenario}: Promotion of the application version from qa to staging-us.
%
%\begin{verbatim}
%	cp envs/qa/version.yml envs/staging-us/version.yml
%\end{verbatim}
%
%\noindent
%\textbf{Scenario}: Promotion of the application from prod-eu to prod-us together with the additional configuration. The settings file(s) are also copied.
%
%\begin{verbatim}
%	cp envs/prod-eu/version.yml envs/prod-us/version.yml
%	cp envs/prod-eu/settings.yml envs/prod-us/settings.yml
%\end{verbatim}
%
%\noindent
%\textbf{Scenario}: Backport all settings from qa to integration-non-gpu.
%
%\begin{verbatim}
%	cp envs/qa/settings.yml envs/integration-non-gpu/settings.yml
%\end{verbatim}
%
%\noindent
%\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
%notes,
%that the copy operations are for illustrative purposes only. 
%In a real-world application, this operation would be performed automatically by a CI system 
%or other orchestration tool. And depending on the environment 
%perhaps a pull request should be created first instead of processing the folder in the main branch directly
%\autocite{codefreshHowToModelGitOpsEnvironmentsAndPromote}.
%\bigskip
%
%\noindent
%\citeauthor{codefreshHowToModelGitOpsEnvironmentsAndPromote} (\citeyear{codefreshHowToModelGitOpsEnvironmentsAndPromote})
%suggests the following advantages of the folder-per-environment approach:
%
%\begin{itemize}
%	\item The order of commits in the Git repository is irrelevant. When a file is copied from one folder to the next, the commit history doesn't matter.
%	\item If only files are copied, only exactly what is needed is promoted, and nothing else.
%	\item No need to use git cherry picks or other advanced git methods to promote releases. Only files need to be copied.
%	\item The user is free to commit any change from any environment to any environment, without any restrictions on the proper "order" of environments.
%	\item Using diff operations on files, it is easy to track what is different between environments in all directions (both in the source and target environments and vice versa).
%\end{itemize}
%
%\noindent
%\autocite{codefreshHowToModelGitOpsEnvironmentsAndPromote}


