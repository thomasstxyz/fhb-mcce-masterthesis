%\chapter{Empirical Work}


\chapter{Interviews with Working Professionals}

This chapter discusses the conducted interviews with the working professionals.
The interviews within this research have the main purpose of helping with
identifying the problem with promotion of releases in GitOps environments,
because there is insufficient prior written literature on this topic.
Working professionals in the GitOps field are interviewed on the topic.
Their personal opinion and practical experience, use cases and concrete problems
are brought up for discussion. The importantance of a solution to the
problem is highlighted and motivated.
With the problem identification in place, several distinct solution objectives
are defined from the basis of the discussions from the interviews.
These solution objectives are then further elaborated in the following chapter
\ref{chapter:prototype} \nameref{chapter:prototype}
of this thesis, where they primarily serve as the basis for the
desired functionality of the developed prototype.

\section{Problem Identification \& Motivation}
\label{interviews:problem-identification}

As a first step in the research process,
the overarching problem with promoting releases in GitOps environments
needs to be looked at in detail.
To help with this process, a series of semi-structured interviews are conducted with
practicing professionals in the GitOps field. In addition, prior written literature
is also brought up to help with identification of the problem.
Furthermore, several distinct problem items are defined,
for further use in the next research activity
\ref{interviews:definitionSolutionObjectives} \nameref{interviews:definitionSolutionObjectives}.
The importance of a practical solution to the problem is accentuated.

\subsection{Problem 1: Promotion is limited to container image}
\label{problem1}

The currently available GitOps toolchains -
from e.g. Flux or Argo Projects -
provide a way to patch the newest container image version
into the desired state defined in Git.
This is offered as a plain commit without human interaction,
and is mostly used, in order to have a desired state in Git updated with
the currently latest version of a container image,
that is available in a specific container image registry.

When promoting new releases of applications or infrastructure resources defined in Git as the 
desired state, it is not only desirable to promote new version tags,
but it is also needed to promote arbitrary resources like any files
defined in the Git repository.

\begin{quotation}
	\noindent
	\enquote*{When you're promoting, you should consider not just the image version, but all Kubernetes resources.}
	% TODO: cite i3
\end{quotation}

Furthermore, it is desirable to have a human approve the changes,
which are done by a machine, e.g. with the help of Git pull requests.

As interview partner 1 says:
\enquote*{I think that very few companies really do Continuous Deployment, most of them want to have some kind of manual release.}
% TODO: cite i2

Interview partner 3 defined a release
as a \enquote*{generic change to the system}:

\begin{quotation}
	\noindent
	\enquote*{I'm almost inclined to say that I don't care what a release is. I'm talking about a general change to the system, and whether you call it a release or a hotfix or a minor change or a major change, I wouldn't make that big of a distinction. And I wouldn't distinguish whether it's about rolling out a new container image or whether it's a change in a ConfigMap, for example.}
	% TODO: cite i3
\end{quotation}

While a container image is a specific type of information inside a file in a desired state definition,
the ConfigMap stands for a generic resource, typically a separate file inside the GitOps repository.
With this statement, the interview partner means, that a release can include any type of information
or resource. When following the principles of GitOps this is usually constrained to a plain text
file in the GitOps repository, which then may be promoted by copying the file contents from
one to another GitOps environment definition.

\begin{quotation}
	\noindent
	\enquote*{It's just a change to the application and or to the application specific infrastructure. So this is how I always try to explain Helm Charts or the Kubernetes Yamls.}
	% TODO: cite i3
\end{quotation}

A solution to this problem could enable users to promote any arbitrary information
like a file or folder in the Git repository,
or another data from another source (e.g. artifact repository).
This is especially valuable, when thinking broadly, that the tool
which implements this problem solution, could also be used as a general
GitOps tool for interfacing with desired state definitions and moving certain
resources, or patching and updating them.

\subsection{Problem 2: Order of promotion to multiple environments}
\label{problem2}

Since currently there is no general standardized tool for promotion to multiple environments with the GitOps approach,
a specific order of promotion through environments can not easily be achieved.

\begin{table}[h]
	\begin{center}
		\begin{tabular}{||c c||} 
			\hline
			Order & Environment \\ [0.5ex] 
			\hline\hline
			1 & DEV \\ 
			\hline
			2 & INT \\ 
			\hline
			3 & QA \\
			\hline
			4 & PERF \\
			\hline
			5 & PRE-PROD \\
			\hline
			6 & PROD \\
			%[1ex]
			\hline
		\end{tabular}
		\caption{Order of promotion to multiple environments}
		\label{table:order-promotion-multi-env}
	\end{center}
\end{table}

The desired specified order of environments could be like interview partner 3 mentioned,
where the core banking system had up to twelve environments,
% TODO: cite i3
which a new application release needed to pass for testing,
in a specific order:

\begin{quotation}
	\noindent
	\enquote*{There have been many, many environments. Production was only a very small part of it.}
	% TODO: cite i3
\end{quotation}

Due to the high criticality in the banking system,
it is the highest priority for an application to run in a stable manner throughout its lifetime,
and for new version releases and new features to not break anything.
The bank has a lot of environments/stages just for testing, in order to ensure the
very high quality of the software.

\begin{quotation}
	\noindent
	\enquote*{The criterion for a stage was on the one hand, the quality level of the software. So does the software still have a lot of bugs, or is it close to acceptance.}
	% TODO: cite i3
\end{quotation}

Additionally to the order of promotion through environments,
there is the problem of rolling out new releases to all environments at once.
When
\enquote*{multi-tenant is not implemented within the application,}
% TODO: cite i3
\enquote*{I do not want to roll out all at the same time.}
% TODO: cite i3
For example, as a platform provider with tenants represented as separate GitOps
environments, it can be desirable to split up the rollout of the new release into
stages. Interview partner 3 discussed this:

\begin{quotation}
	\noindent
	\enquote*{I first deployed the new version for the unimportant customer, now I also want to use it with the important customer.}
	% TODO: cite i3
\end{quotation}

\begin{table}[h]
\begin{center}
\begin{tabular}{ |p{2.8cm}||p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|  }
	\hline
	Tenant/Customer & A & B & C & D\\
	\hline
	Stage 1   & v1 --> v2    &v1&   v1 & v1\\
	Stage 2 &   v2  & v1 --> v2   & v1 --> v2 & v1\\
	Stage 3 &v2 & v2&  v2 & v1 --> v2 \\
	Stage 4 &v2 & v2&  v2 & v2\\
	\hline
\end{tabular}
\caption{Rollout to environments in stages}
\label{table:rollout-envs-stages}
\end{center}
\end{table}

A solution to this problem formulation is especially valuable for
use cases with a high amount of regulations like e.g. financial institutions.

\subsection{Problem 3: Dependencies can not be defined}
\label{problem3}

Before promoting a new release to another environment,
it may be desirable to have specific
quality gates, which define the quality standards the
software must meet, in order to be considered for a promotion.
These can be integration and end-to-end tests for example.
Additionally with a monitoring and observability tool,
certain metrics can be evaluated with the new release,
and if they do not meet a certain value, the release would not
be a candidate for promotion.
As a minimum, it must be ensured that the new version is 
deploying correctly. When only given the desired state definiton
in Git, it can not be measured, if the system will end up in a running
and successful deployment.

\begin{quotation}
	\noindent
	\enquote*{It may well be that you have dependencies between applications. I often take the approach that I have one GitOps repo per application or microservice. Now, for example, you want to promote the new version of one repo first, if the other one is also on a certain level, then there is the issue of dependencies to infrastructures, to databases, etc.}
	% TODO: cite i3
\end{quotation}

To provide an example, in the context of the Kubernetes platform,
an application may need an internal service or any other external (to Kubernetes)
dependency like a managed database.
When thinking of release promotion,
a dependency might be a Kubernetes object like a job or another custom resource,
which - when it is observed with a ready or successful status -
can be seen as a test result or in prinicple a quality gate, which qualifies the
new application release for promotion.

A solution to this problem statement is especially valuable when having the whole
continuous delivery lifecycle in mind. After deployment of a new application release
to a certain environment, it should be evaluated for its quality. So, tests
and other metrics should be evaluated, in order to ensure high software quality
at every stage in the development and also deployment cycle,
all this in a fully automated way.

\subsection{Problem 4: Provider and tool dependency}
\label{problem4}

With the currently available GitOps toolchains,
and due to the lack of best practices and standardized solutions,
users or platform engineers are inclined to build
and setup
\enquote*{advanced complex pipelines that are kind of like all interdependent on a lot of things.}
% TODO: cite i1
This usually results in tight coupling of the Git provider, the GitOps engine, the CI workflow/pipeline platform,
configuration management tools, and other components.
Additionally there need to be permissions and policies granted to many different people and
machines on many different systems.
In the end, it results in vendor lock-in and tightly coupled toolchains.

A solution to this problem enables users to avoid vendor lock-in as much as possible.
This fits well with the Kubernetes ecosystem, which is currently the most prominent
cloud native software platform,
in that it also tries to be cloud and platform agnostic at every step of the way.
With Kubernetes it is always desirable that applications running on the platform can
run on any type of infrastructure.











\section{Definition of Solution Objectives}\label{interviews:definitionSolutionObjectives}

Now that the problem has been identified in the earlier section
\ref{interviews:problem-identification} \nameref{interviews:problem-identification},
research objectives of a solution to the problem will be inferred.
Each research objective provides a solution to a distinct problem item
(fig. \ref{fig:from-problem-to-objective-visualized}).
A research objective is a qualitative description of how a functionality
of the developed prototype is expected to support a solution to the problem definition.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.55\linewidth]{assets/from-problem-to-objective-visualized.png}
	\caption{Definition of Solution Objectives by inferring from Problem Definitions.
		%		(\citeauthor{ref}, \citeyear{ref}).
	}
	\label{fig:from-problem-to-objective-visualized}	
\end{figure}

\subsection{Objective 1: Arbitrary resources can be promoted}
\label{objective1}

From the problem definition
\textbf{\nameref{problem1}},
a solution objective
\textbf{\nameref{objective1}},
is inferred.
A qualitative description of the solution objective
is pointed out in the following.

A promotion subject, which is promoted between GitOps environments can potentially
be of many types. A popular type of data, which can be promoted,
is the version tag of the container image of a particular application.
For some use cases it is not sufficient to promote only the version of the container image.
In order to provide a solution to this problem,
the solution must provide a way to promote arbitrary types of resources.
In the GitOps context, resources are typically constrained to declarative
representations in plain text format, which are defined in a Git repository.
By providing a way to copy user defined files or directories in the form
of filesystem paths inside a Git repository,
potentially any type of resource may be a possible subject for promotion.
When GitOps environments are stored in multiple, separate Git repositories,
there needs to be the functionality to copy between these repositories.
Furthermore, for these arbitrary files or directories in GitOps repositories
a descriptive name for a certain file or directory
should be defined alongside the
respective copy operation of the promotion subject.
This is useful for identifying the specific promotion subject
on a higher abstract level.
This way, for example, an application's environment variables,
which are defined and actually disguised as a Kustomize overlay in a Kubernetes deployment resource,
can be given a friendly name like "Environment variables/Application Configuration".
This makes it a lot easier to identify a particular promotion subject, without
needing to manually inspect the raw contents of a file or even multiple files or
directory trees.

A collection of the requirements for the solution objective is shown below
Each requirement is represented in the form of a user story,
and is labelled with a code, from a combination of the
objective's code (e.g. OBJ1) and the requirement's code (e.g. R1).

\begin{itemize}
	\item \textbf{OBJ1R1}: \setword{As a user, I can define any filesystem path inside a Git repository, with a respective target path in a Git repository, as a promotion subject.}{OBJ1R1}
	\item \textbf{OBJ1R2}: \setword{As a user, I can define a descriptive name for a promotion subject, which is represented as an arbitrary filesystem path.}{OBJ1R2}
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.79\linewidth]{assets/OBJ1R1-and-OBJ1R2.png}
	\caption{OBJ1R1 and OBJ1R2.
		%		(\citeauthor{ref}, \citeyear{ref}).
	}
	\label{fig:OBJ1R1-and-OBJ1R2}	
\end{figure}

\subsection{Objective 2: Strict flow of promotion through environments}
\label{objective2}

From the problem definition
\textbf{\nameref{problem2}},
a solution objective
\textbf{\nameref{objective2}},
is inferred.
A qualitative description of the solution objective
is pointed out in the following.

When promoting a new application release to multiple environments,
it may be necessary to define a certain order, in which the promotion proceeds
through the environments.
This can have many reasons,
as defined in the problem identification section \ref{problem2} earlier.
A release may be rolled out to the initial development environment continuously,
without any quality gates or other checks, to ensure software code and runtime quality.
However, in order for a new version release to proceed to environments like
performance test environments, which can produce high resource costs for each test,
it may be useful to control the deployment to certain environments and this way, further constrain
the deployment to subsequent environments, with a step in between.
Another use case for this solution objective is for service providers
with a multi-tenant architecture, which is implemented with GitOps environments.
These service or platform providers may want to rollout a new release with a certain staging process.

A collection of the requirements for the solution objective is shown below
Each requirement is represented in the form of a user story,
and is labelled with a code, from a combination of the
objective's code (e.g. OBJ2) and the requirement's code (e.g. R1).

\begin{itemize}
	\item \textbf{OBJ2R1}: \setword{As a user, I can promote releases through multiple environments in a certain user-defined order.}{OBJ2R1}
%	\item \textbf{OBJ2R2}: \setword{As a user, I can rollout a release to specific environments, while leaving others untouched.}{OBJ2R2}
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\linewidth]{assets/OBJ2R1.png}
	\caption{OBJ2R1.
		%		(\citeauthor{ref}, \citeyear{ref}).
	}
	\label{fig:OBJ2R1}	
\end{figure}

\subsection{Objective 3: Dependencies of a promotion}
\label{objective3}

From the problem definition
\textbf{\nameref{problem3}},
a solution objective
\textbf{\nameref{objective3}},
is inferred.
A qualitative description of the solution objective
is pointed out in the following.

After deploying a new release to a certain environment,
the minimum requirement for further proceeding to a subsequent deployment environment,
is typically to check if the application was deployed successfully and is running in a healthy state.
While this is the minimum that should always be ensured before promotion,
other types of processes may be done, in order to reduce the likelihood of delivering bad quality software,
which could likely be introduced by a bad release.
One of these can be to have dependencies for a promotion.
In the context of Kubernetes, this could be another Kubernetes workload, or any other object or custom resource.
Kubernetes native testing tools or workflow engines may provide custom resources with Kubernetes API conformant
conditions, in order for other programs to check the state of the resource, in particular this may be the ready condition.

A collection of the requirements for the solution objective is shown below
Each requirement is represented in the form of a user story,
and is labelled with a code, from a combination of the
objective's code (e.g. OBJ3) and the requirement's code (e.g. R1).

\begin{itemize}
	\item \textbf{OBJ3R1}: \setword{As a user, I can define Kubernetes objects as dependencies for a promotion.}{OBJ3R1}
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.82\linewidth]{assets/OBJ3R1.png}
	\caption{OBJ3R1.
		%		(\citeauthor{ref}, \citeyear{ref}).
	}
	\label{fig:OBJ3R1}	
\end{figure}

\subsection{Objective 4: Vendor-neutral, tool-agnostic}
\label{objective4}

From the problem definition
\textbf{\nameref{problem4}},
a solution objective
\textbf{\nameref{objective4}},
is inferred.
A qualitative description of the solution objective
is pointed out in the following.

When following current good practices and guidelines
to build a promotion setup for GitOps environments,
users are inclined to build workflows which are constrained to specific Git providers, GitOps engines,
CI pipeline and configuration tools. This leads to tightly coupled setups,
and vendor lock-in.
With the strong open-source foundation of the Kubernetes platform and ecosystem,
it is a good practice to build additional tools and platforms on top of Kubernetes,
in order to remain cloud and vendor agnostic. In the space of GitOps promotions,
there is currently insufficient tooling for this purpose.
Therefore, one solution objective of this research is to
provide a generic tool,
which is vendor-neutral,
and agnostic to the Git provider, as well as the configuration/templating tool.

A collection of the requirements for the solution objective is shown below
Each requirement is represented in the form of a user story,
and is labelled with a code, from a combination of the
objective's code (e.g. OBJ4) and the requirement's code (e.g. R1).

\begin{itemize}
	\item \textbf{OBJ4R1}: \setword{As a user, I can use any GitOps engine, Git provider and configuration/templating tool.}{OBJ4R1}
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.80\linewidth]{assets/OBJ4R1.png}
	\caption{OBJ4R1.
		%		(\citeauthor{ref}, \citeyear{ref}).
	}
	\label{fig:OBJ4R1}	
\end{figure}










\section{Summary}

TODO


















\chapter{GitOps Promotions Operator Prototype}
\label{chapter:prototype}

This chapter describes the developed prototype,
called the GitOps Promotions Operator.

First, the asynchronous nature of a typical GitOps deployment is described,
and where the proposed GitOps Promotions Operator prototype finds its place within
this architecture.
Next, abstract models are designed which describe the Environment and Promotion 
custom resources; which are then afterwards implemented as mockups of 
Kubernetes custom resources in the declarative Yaml specification syntax.
Next to the mockups implemented in the prototype,
additional alternative mockups are suggested for possible alternative implementations.
Then, the implementation of the custom resource definitions and respective controller logic
is described within the context of the used Kubernetes operator framework Kubebuilder.

Once the design and development of the artifact - the GitOps Promotions Operator prototype -
is successfully done,
the operator is demonstrated in a proof of concept,
and finally evaluated against the solution objectives
from section \ref{interviews:definitionSolutionObjectives}.

\section{Design \& Development}

The design and development of the prototype
is based on the research objectives defined in section
\ref{interviews:definitionSolutionObjectives}.
The overarching goal is to fulfill the objectives with the developed artifact,
the GitOps Promotions Operator prototype.
This is shown by demonstrating the functionality and evaluating against the research objectives.

\subsection{Asynchronous GitOps Deployments}

First, the process of a typical GitOps deployment needs to be addressed;
the proposed GitOps Promotions Operator needs to find its place in this asynchronous process.
It begins with a change of the declarative state definitions in a Git repository,
which is then being reconciled by the GitOps controller.
The timeframe from the change of the desired state to the actual state being applied
is variable. An external system (i.e. the GitOps Promotions Operator), which watches the desired state, has no knowledge of
the current state of the deployment environment - when solely given the desired state in the
Git repository. An external system also does not know whether the desired state works or not
(e.g. when the new version fails to rollout).

The proposed GitOps Promotions Operator ideally needs to pick up
the asynchronous deployment process after the new release of the desired state
has been successfully rolled out to the deployment environment.
In order to achieve this,
it needs to at least check the availability of the deployed application or workload,
before continuing on with the promotion.
The described asynchronous GitOps deployment and promotion model can be seen in figure
\ref{fig:async-gitops-promo-arch}.

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\linewidth]{assets/async-gitops-promo-arch.png}
	\caption{Asynchronous GitOps deployment and promotion.
		%		(\citeauthor{ref}, \citeyear{ref}).
	}
	\label{fig:async-gitops-promo-arch}	
\end{figure}

In order for the proposed GitOps Promotions Operator prototype to fit into
this asynchronous deployment architecture,
it needs to have several asynchronous phases in its controller logic.
The minimum steps or phases it needs are the following:

\begin{enumerate}
	\item watch deployment environment
	\item wait for successful deployment
	\item trigger promotion
\end{enumerate}

In order to check if a deployment was successful,
the GitOps Promotions Operator needs access to the deployment environment. This is already given,
if the operator is running inside the same deployment environment.
For the promotion process, the operator also needs access
to the source and the target
environment (Git repository).
The described architecture can be viewed in figure \ref{fig:operator-access-source-target-envs}.

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\linewidth]{assets/operator-access-source-target-envs.png}
	\caption{GitOps Promotions Operator Promotion from source to target environment.
		%		(\citeauthor{ref}, \citeyear{ref}).
	}
	\label{fig:operator-access-source-target-envs}	
\end{figure}

%\subsection{old intro.....}
%
%The GitOps Promotions Operator prototype
%is implemented with the Kubebuilder framework,
%discussed in section \ref{theoretical-background:kubernetes} of this thesis.
%The main constraints the framework comes with, are the
%custom resource definition + controller pattern.
%
%\begin{figure}[h]
%	\centering
%	\includegraphics[width=1.00\linewidth]{assets/crd-and-controller.png}
%	\caption{Custom Resource Definition and Controller.
%		%		(\citeauthor{ref}, \citeyear{ref}).
%	}
%	\label{fig:crd-and-controller}	
%\end{figure}
%
%As the initial step of the design phase,
%abstract model definitions are designed.
%Their key properties are identified.
%Then a sample mockup is designed as
%a custom resource definition in Yaml format.
%Afterwards this idea of the model definition is 
%translated into custom struct types of the
%Go programming language,
%which is chosen by the Kubebuilder framework.

Once the architecture of the asynchronous GitOps deployment process,
and where the GitOps Promotions Operator fits within this process is clear,
the abstract models for the custom resources and their functionality can be designed.

\subsection{Abstract Models}
	
In order to be able to represent environments and promotions,
the requirement is to at least start with two abstract models for each 
the environment and the promotion.

The Environment represents a GitOps environment,
which is a Git repository + path.
The Git repository can be a clone URL to the repository,
and the path is the relative filesystem path, which points to the 
environment, inside the repository.

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\linewidth]{assets/gitops-env-repo-and-path.png}
	\caption{GitOps Environment.
		%		(\citeauthor{ref}, \citeyear{ref}).
	}
	\label{fig:gitops-env-repo-and-path}	
\end{figure}

The abstract model for a GitOps environment needs at least the following properties:

\begin{itemize}
	\item URL of the source Git repository
	\item Path pointing to the environment inside the repository
	\item Dependent resources inside the deployment environment
\end{itemize}

The URL has the format of a HTTP(S) or SSH URL,
which links to the Git repository,
e.g.:

\begin{itemize}
	\item \lstinline|http://localhost:8080/org/repo|
	\item \lstinline|https://gitprovider.com/org/repo|
	\item \lstinline|ssh://git@gitprovider.com:org/repo|
\end{itemize}

The path has the format of a typical unix style filesystem path.
It starts relative from the root of the given Git repository,
and points to the directory, which represents the GitOps environment.
Examples for a path are the following:

\begin{itemize}
	\item \lstinline|path/to/env|
	\item \lstinline|/path/to/env|
	\item \lstinline|./path/to/env|
	\item \lstinline|./path/to/env/|
\end{itemize}

Note, that these example paths all represent the same directory,
these are just alternative notations.

The dependent resources are the resources (objects) in the deployment environment,
which need to be successfully deployed, in order for the promotion to trigger.

The abstract model for a GitOps promotion
(fig. \ref{fig:gitops-promo})
needs at least the following properties:

\begin{itemize}
	\item source environment
	\item target environment
	\item promotion subjects
	\item promotion strategy
\end{itemize}

The source environment defines the environment resource,
where a promotion subject is promoted from.
The target environment defines the environment resource,
where a promotion should promote to.

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\linewidth]{assets/gitops-promo.png}
	\caption{GitOps Promotion.
		%		(\citeauthor{ref}, \citeyear{ref}).
	}
	\label{fig:gitops-promo}	
\end{figure}

A promotion subject can be potentially many different things.
In the case of this prototype,
a promotion subject is a file or directory,
which is copied from the source to the target environment.
Examples of such files or directories are the following:

\begin{itemize}
	\item \lstinline|kustomization.yaml|
	\item \lstinline|./component/cert-manager/kustomization.yaml|
	\item \lstinline|./helm-values-prod.yaml|
\end{itemize}

Note, that the relative paths of the promotion subjects,
are relative to the paths of the environment, defined earlier.
An example of the \lstinline|kustomization.yaml|, would look like this:

\lstinline|./path/to/env/kustomization.yaml|

As an example - but outside the scope of the current prototype -
a promotion subject could also be fetched from another source,
like an artifact registry, or be any other type of data
and updated/promoted in the target environment,
e.g. a version tag, helm values, etc.

With the current prototype,
the promotion strategy is to raise a pull request at the Git provider
(fig. \ref{fig:raise-pull-request-and-approve}),
with the changes proposed by the promotion.
A human can then review the changes and optionally approve and merge the pull request.
After merging, the promotion will have taken place.

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\linewidth]{assets/raise-pull-request-and-approve.png}
	\caption{Raise Pull Request at target environment.
		%		(\citeauthor{ref}, \citeyear{ref}).
	}
	\label{fig:raise-pull-request-and-approve}	
\end{figure}

Alternatively to a pull request, the changes could be directly
commited and pushed to the target environment,
without human interaction. This strategy should require different means
of automated or otherwise external or additional checks, in order to ensure a safe promotion.
This strategy is not implemented in the developed prototype.

Now that the abstract models are designed,
they need to be implemented.
Since the decision for the prototype is to be developed
with the Kubebuilder framework and follow its style,
mockups of the custom resources in Yaml format
will be created as a next step.









\subsection{Mockups of Custom Resources}

%to write mockups
%of custom resources in YAML format,
%since this is what the end user will interface with when the application is finished.
%First and foremost the handling and user experience has to be seamless and make sense
%for the user; also it shouldn't take any extra miles for the user to take,
%just to get started.
%The YAML representation of the custom resource should be similar to other ones
%from the Kubernetes core types.

When the abstract models have been specified,
they can be actually implemented with the framework
as Kubernetes custom resource definitions.

Users will mainly be dealing with the custom resources in a Yaml format.
Yaml keys should be intuitive and make sense to the user.
It also helps if they follow the core Kubernetes definitions regarding naming conventions.
An example for a naming convention is the "Ref" suffix for yaml keys.
This suffix is typically appended to keys which represent a reference to another Kubernetes
object.
For example, "secretRef" says that this field refers to a Kubernetes secret resource.

A possible mockup for a GitOps environment -
that is a first prototype implementation of the abstract model into a custom resource -
could look like the following.

\lstinputlisting{assets/files/environment-mockup.yaml}

In this mockup the \lstinline|.spec.dependentObjects.workloadRef|
represents a list of Kubernetes objects in the cluster,
which need to be successfully deployed,
before a promotion is triggered.
Additionally the git reference branch main is also specified \\
in the \lstinline|.spec.source.ref.branch| field.

A possible mockup for a GitOps promotion 
could look like the following.

\lstinputlisting{assets/files/promotion-mockup.yaml}

In the promotion mockup definition,\\
there are four main fields within the \lstinline|.spec|.
These represent the minimum properties of the previously defined abstract definition.
It is to note, that
the \lstinline|.spec.copy| field represents the promotion subjects.
It is a list of items, where each item contains
a \lstinline|name|, \lstinline|source| and \lstinline|target|.
The \lstinline|name| defines a custom name.
The \lstinline|source| and \lstinline|target| fields together define a
file copy operation,
where the \lstinline|source| is the relative path from the source environment,
and the \lstinline|target| is a relative path from the target environment.

\subsection{Alternative Mockups}

The following alternative mockups,
for the custom resource definitions,
i.e. the design of the declarative API,
are suggested, but not implemented in the current prototype.

\subsubsection*{Promotion Subjects defined in each Environment resource}

Alternatively, the promotion subjects could also be specified
in the environment resource.
Then the environment could like the following:

\lstinputlisting{assets/files/environment-mockup-alt-1.yaml}

In the promotion definition,
it would then suffice to specify
a list of promotion subjects.

\lstinputlisting{assets/files/promotion-mockup-alt-1.yaml}

This alternative design allows that each environment could have
a unique path of a specific promotion subject defined.
Now if a promotion is spanning over multiple environments,
they could each specify their own unique path to a promotion subject.
The promotion subject is declared in the promotion,
but the actual path is defined per each environment.

\subsection{Translation to Go types}

Once the mockups of the custom resources in Yaml format are done,
the declarative structure can be translated to custom Go types.

The specification of the Environment resource results in the following code:

% TODO: needs update after dependentObjects implementation

\lstinputlisting{assets/files/environmentSpec-type.go}

The type EnvironmentSpec represents the \lstinline|.spec| Yaml field.

What also needs to be defined is the status subresource.
In the status fields, the controller can save the current/actual state
of the resource during runtime.
While \lstinline|.spec| defines the desired state,
\lstinline|.status| defines the actual state, as observed by the controller.

% TODO: maybe show example of .status yaml

\lstinputlisting{assets/files/environmentStatusSpec-type.go}

The specification of the Promotion resource results in the following code:

\lstinputlisting{assets/files/promotionSpec-type.go}

For the promotion,
a status subresource is also defined.
In the status - the actual state of the resource as observed by the controller -
most importantly the metadata of the currently opened pull request is saved,
which the controller will pick up on every consecutive reconciliation
of the same promotion object.

\lstinputlisting{assets/files/promotionStatusSpec-type.go}

The full source code of the types can be found in Appendix
\ref{appendix:source-code}.

Once the Go types are defined,
the controller logic can be written.

\subsection{Controller Logic}

For the environment API,
a controller is written.
For this prototype the following logic was implemented.
First, the source git repository is cloned and checked out,
with the appropriate authentication options, if it is private.
If it succeeds, the Ready condition is set in the status subresource,
which will mark it as available and ready.

\begin{enumerate}
	\item test the clone of Git repository with authentication
	\item checkout reference branch locally
	\item mark environment as ready
\end{enumerate}

For the promotion API,
the following controller logic is implemented.
First, the controller checks if the source and target environments are ready,
this includes the check of their defined dependent objects.
if they are not yet ready, the controller cancels the reconciliation immediately.
Then the source and target environments are cloned.
Next the controller checks if there is a pending/open pull request,
this information is retrieved from the object's status, and then checked
if still up to date via the Git provider's API.
Afterwards the controller executes the promotion tasks,
which are the copy operations with the current state of the prototype.
Now if there were changes since the last reconciliation, the new commits
are pushed to the pull request branch.
Lastly, a pull request will be raised, if not yet done during a previous reconciliation.

\begin{enumerate}
	\item ensure that the source and target environments are ready
	\item clone source and target repositories
	\item check for a pending promotion (open Pull Request)
	\item execute the promotion copy operations
	\item push new commits to PR branch, if there were differences between source \& target environments
	\item create new PR, if not yet opened
\end{enumerate}

The full source code of the controllers can be found in Appendix
\ref{appendix:source-code}.















\section{Demonstration}
\label{prototype:demonstration}

The following section demonstrates the in-context usage of the
developed prototype - the GitOps Promotions Operator - in a proof of concept.
The use case described as follows is created for the purpose of this demonstration.

This use case deals with a setup with multiple deployment environments.
There are two non-critical environments \lstinline|dev| and \lstinline|qa|,
and two production environments \lstinline|prod-1| and \lstinline|prod-2|.
The GitOps definitions of the non-critical environments are living inside the same
Git repository \lstinline|mtpoc-infra-1|,
and each production environment lives in its own separate Git repository
\lstinline|mtpoc-infra-2| for \lstinline|prod-1|,
and \lstinline|mtpoc-infra-3| for \lstinline|prod-2|.
In general, the application version shall be promoted with a strict flow
through the environments, one after the other.
An overview of the given setup can be seen in the table \ref{table:poc-environments-setup}.

\begin{table}[h]
\begin{center}
	\begin{tabular}{||c c c||} 
		\hline
		Order & Environment & Source Repository \\ [0.5ex] 
		\hline\hline
		1 & dev & mtpoc-infra-1 \\ 
		\hline
		2 & qa & mtpoc-infra-1 \\
		\hline
		3 & prod-1 & mtpoc-infra-2 \\
		\hline
		4 & prod-2 & mtpoc-infra-3 \\
%		[1ex]
		\hline
	\end{tabular}
	\caption{PoC Environments Setup}
	\label{table:poc-environments-setup}
\end{center}
\end{table}

The GitOps environment is centered around the used configuration management tool
Kustomize, and generally structured for all environments as below:

\begin{lstlisting}
.
|-- app-version
|   `-- kustomization.yaml
|-- kustomization.yaml
`-- settings
    `-- deployment.yaml
\end{lstlisting}

This structure adheres to the constraints of the currently available
copy operation promotion type, which can copy files and directories.
This means the configuration components which need to be promoted,
should be defined in separate files or directories.
This is needed, in order to only promote e.g. the application image version,
while leaving other configuration untouched, and specific to an environment.
With the Kustomize configuration tool, it is possible to split
parts of the main \lstinline|kustomization.yaml| into other separated files,
with the components feature.

In this use case, the value of the application's image version lives within the 
app-version component. This is configured in the main \lstinline|kustomization.yaml|
like this:

\begin{lstlisting}
components:
- app-version
\end{lstlisting}

The \lstinline|./app-version| directory contains a \lstinline|kustomization.yaml| file,
with typical Kustomization specification.
In this case, the images feature of Kustomize is used for configuring the application's
image version tag.

\begin{lstlisting}
apiVersion: kustomize.config.k8s.io/v1alpha1
kind: Component
images:
- name: ghcr.io/stefanprodan/podinfo
newTag: 6.3.4
\end{lstlisting}

Now the goal is to configure a promotion for the app-version component.
To achieve this, 
first, a \lstinline|Environment| resource needs to be created
for all environments respectively.
Only the \lstinline|dev| environment is shown here,
the other three environment definitions follow the same schema,
but are omitted for the sake of brevity.

\lstinputlisting{assets/files/dev-environment.yaml}

%\lstinputlisting{assets/files/qa-environment.yaml}
%
%\lstinputlisting{assets/files/prod-1-environment.yaml}
%
%\lstinputlisting{assets/files/prod-2-environment.yaml}

Now the specified secrets must be created.
The API token is required for the creation of pull requests by the promotion controller;
it must be stored in a Kubernetes generic secret resource in a key named \lstinline|token|,
and can be created with the following command:

\lstinline|kubectl create secret generic github-api-token --from-literal=token="gh..."|

With the current prototype, also a secret for the SSH connection to push and pull
the repository, needs to be created.
For this, a ssh key pair needs to be created by the user. Its public key needs to 
be set as a deploy key at the Git provider,
and its private key needs to be stored in a
Kubernetes generic secret resource in a key named \lstinline|private|.

\lstinline|kubectl create secret generic github-api-token --from-literal=private="--..."|

When all the four environments are created, the \lstinline|Promotion| resources
can be defined.
In this use case, three promotion resources are needed for the ability to
promote between all four environments with a straight flow - promoting from one to the next.
Only the \lstinline|dev-to-qa| promotion is shown here,
the other two definitions follow the same schema,
but are omitted here for the sake of brevity.

\lstinputlisting{assets/files/dev-to-qa.yaml}

%\lstinputlisting{assets/files/qa-to-prod-1.yaml}
%
%\lstinputlisting{assets/files/prod-1-to-prod-2.yaml}





At this point, all which is needed for promoting is configured.
When the status of all the environment resources involved in a promotion,
have a ready status condition,
and the dependent objects are successfully deployed,
a promotion will trigger.

\lstinputlisting{assets/files/env-dev-status.yaml}

At this point, the controller logs can be observed.

\begin{lstlisting}
2023-04-16T12:10:40Z    INFO    Begin reconciling Promotion     {"controller": "promotion", "controllerGroup": "promotions.gitopsprom.io", "controllerKind": "Promotion", "Promotion": {"name":"dev-to-qa","namespace":"default"}, "namespace": "default", "name": "dev-to-qa", "reconcileID": "ba3775ae-d8b1-40de-ad7b-4f42f8534686", "name": {"namespace": "default", "name": "dev-to-qa"}}
2023-04-16T12:10:46Z    INFO    Created new pull request        {"controller": "promotion", "controllerGroup": "promotions.gitopsprom.io", "controllerKind": "Promotion", "Promotion": {"name":"dev-to-qa","namespace":"default"}, "namespace": "default", "name": "dev-to-qa", "reconcileID": "ba3775ae-d8b1-40de-ad7b-4f42f8534686", "WebURL": "https://github.com/thomasstxyz/mtpoc-infra-1/pull/1"}
2023-04-16T12:10:46Z    INFO    Reconciled Promotion successfully       {"controller": "promotion", "controllerGroup": "promotions.gitopsprom.io", "controllerKind": "Promotion", "Promotion": {"name":"dev-to-qa","namespace":"default"}, "namespace": "default", "name": "dev-to-qa", "reconcileID": "ba3775ae-d8b1-40de-ad7b-4f42f8534686", "duration": "6.050374419s", "nextReconcile": "300s"}
\end{lstlisting}

A new pull request
%with the number \lstinline|1|
%at the Web URL \\
%\url{https://github.com/thomasstxyz/mtpoc-infra-1/pull/1} \\
has been created by the controller.

The promotion's status will also reflect, that
a pull request is open for review.

\lstinputlisting{assets/files/prom-dev-to-qa-status.yaml}

The open pull request is ready for review in the Git provider's web interface.
%\begin{figure}[h]
%	\centering
%	\includegraphics[width=1.00\linewidth]{assets/new-promotion-github.png}
%	\caption{New Git Pull Request.
%		%		(\citeauthor{ref}, \citeyear{ref}).
%	}
%	\label{fig:new-promotion-github}	
%\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\linewidth]{assets/prom-pr-dev-to-qa.png}
	\caption{Pull Request for Promotion from dev to qa.
		%		(\citeauthor{ref}, \citeyear{ref}).
	}
	\label{fig:prom-pr-dev-to-qa}	
\end{figure}

The changed difference introduced by the commit can be viewed:

\begin{lstlisting}
- newTag: 6.3.3
+ newTag: 6.3.4
\end{lstlisting}

The \lstinline|dev-to-qa| promotion requested the change of the image version from
\lstinline|6.3.3| to \lstinline|6.3.4|.

Now, since the \lstinline|qa| and the \lstinline|prod-1| environments
also differ,
a pull request has also been created for this promotion.

%\begin{figure}[h]
%	\centering
%	\includegraphics[width=1.00\linewidth]{assets/prom-pr-qa-to-prod-1.png}
%	\caption{Pull Request for Promotion from qa to prod-1.
%		%		(\citeauthor{ref}, \citeyear{ref}).
%	}
%	\label{fig:prom-pr-qa-to-prod-1}	
%\end{figure}

The \lstinline|qa-to-prod-1| promotion requested the change of the image version from
\lstinline|6.3.2| to \lstinline|6.3.3|.

\begin{lstlisting}
- newTag: 6.3.2
+ newTag: 6.3.3
\end{lstlisting}

Now, since the \lstinline|prod-1| and the \lstinline|prod-2| environments
also differ,
a pull request has also been created for this promotion.

%\begin{figure}[h]
%	\centering
%	\includegraphics[width=1.00\linewidth]{assets/prom-pr-prod-1-to-prod-2.png}
%	\caption{Pull Request for Promotion from prod-1 to prod-2.
%		%		(\citeauthor{ref}, \citeyear{ref}).
%	}
%	\label{fig:prom-pr-prod-1-to-prod-2}	
%\end{figure}

The \lstinline|prod-1-to-prod-2| promotion requested the change of the image version from
\lstinline|6.3.1| to \lstinline|6.3.2|.

\begin{lstlisting}
- newTag: 6.3.1
+ newTag: 6.3.2
\end{lstlisting}

If the \lstinline|dev| environment advances the application image version further,
the pull request for the \lstinline|dev-to-qa| will be updated with another commit.
Note that the previous commit is not overwritten, 
but the commit history is kept on the pull request branch - now there are two commits on the branch.

\begin{figure}[h]
	\centering
	\includegraphics[width=1.00\linewidth]{assets/prom-pr-dev-to-qa-round2.png}
	\caption{Pull Request updated for Promotion from dev to qa.
		%		(\citeauthor{ref}, \citeyear{ref}).
	}
	\label{fig:prom-pr-dev-to-qa-round2}	
\end{figure}

The difference for the \lstinline|dev-to-qa| promotion is now:

\begin{lstlisting}
- newTag: 6.3.3
+ newTag: 6.3.5
\end{lstlisting}

%\begin{figure}[h]
%	\centering
%	\includegraphics[width=1.00\linewidth]{assets/prom-pr-dev-to-qa-round2-diff.png}
%	\caption{Pull Request updated for Promotion from dev to qa (diff).
%		%		(\citeauthor{ref}, \citeyear{ref}).
%	}
%	\label{fig:prom-pr-dev-to-qa-round2-diff}	
%\end{figure}

Now if the pull request for the \lstinline|dev-to-qa| promotion
is approved and merged by a human,
the promotion will actually take effect.
This will results in the \lstinline|qa-to-prod-1| promotion pull request being updated
by the promotion controller.
Version \lstinline|6.3.5| is now requested for promotion to the
\lstinline|prod-1| environment.

The difference for the \lstinline|qa-to-prod-1| promotion is now:

\begin{lstlisting}
- newTag: 6.3.2
+ newTag: 6.3.5
\end{lstlisting}

Once reviewed, approved and merged by a human,
the promotion of version \lstinline|6.3.5| to the \lstinline|prod-1| environment
will result in further propagation of version \lstinline|6.3.5|
to the \lstinline|prod-2| environment.

The difference for the \lstinline|prod-1-to-prod-2| promotion pull request is now:

\begin{lstlisting}
- newTag: 6.3.1
+ newTag: 6.3.5
\end{lstlisting}

Once reviewed, approved and merged by a human,
the promotion of version \lstinline|6.3.5| to the \lstinline|prod-2| environment
will take effect.

The described demonstration showed,
how an application version can be promoted across multiple environments,
while ensuring a strict flow of promotion of \\
e.g. \lstinline|dev --> qa --> prod-1 --> prod-2|.




%For this demonstration, it is supposed that
%the latest version \lstinline|6.3.5| is bad and should not be promoted,
%instead the \lstinline|dev| environment shall be rolled back to \lstinline|6.3.4|.






















\section{Evaluation}

Now that the prototype has been demonstrated in a proof of concept,
its functionality can be compared against the solution objectives,
as defined in section
\ref{interviews:definitionSolutionObjectives}
earlier in this thesis.

\subsection*{Objective 1}

The requirement 1 of objective 1 (OBJ1R1), formulated as a user story,
was the following:

\begin{quotation}
	\noindent
	\ref{OBJ1R1}
\end{quotation}

As demonstrated in section
\ref{prototype:demonstration}
the user of the GitOps Promotions Operator can define promotion subjects
in the form of file/directory copy operations inside the Promotion custom resource.
The source and target may be in separate Git repositories, respective Environment custom resources.
This creates the possibility to promote arbitrary resources.
The demonstration shows a promotion of the "Application Version",
which is actually a specified file kustomization.yaml with a Kustomize component,
which sets a new image tag.
The defined name of the arbitrary filesystem path serves as the demonstration for the requirement 2 (OBJ1R2).

\begin{quotation}
	\noindent
	\ref{OBJ1R2}
\end{quotation}

The definition of such a descriptive name helps to identify promotion subjects more easily, especially when
they are arbitrary files or directories. The name can be represented in the commit message or pull request, as demonstrated.

\subsection*{Objective 2}

The requirement 1 of objective 2 (OBJ2R1) was the following:

\begin{quotation}
	\noindent
	\ref{OBJ2R1}
\end{quotation}

The in the prototype implemented functionality of the solution objective is demonstrated in section
\ref{prototype:demonstration}.
It is shown, how a new application release can be promoted through multiple environments in a specified order.
After deployment to the dev environment, a promotion is requested for the qa environment.
Once a human has approved and merged the pull request, the promotion to qa takes its effect.
Afterwards the promotion from qa to prod-1 environment is requested. Upon successful promotion to prod-1,
the release is finally promoted from prod-1 to prod-2.

\subsection*{Objective 3}

The requirement 1 of objective 3 (OBJ3R1) was the following:

\begin{quotation}
	\noindent
	\ref{OBJ3R1}
\end{quotation}

The functionality of this objective is demonstrated in context in the proof of concept
in section \ref{prototype:demonstration}.
In the \lstinline|Environment| custom resource,
a field \lstinline|dependentObjects.workloadRef| may be defined, under which a user can specify
a list of Kubernetes workloads of the kind Deployment.
The developed prototype supports object types of kind Deployment,
however, any Kubernetes native resource, as well as custom resource, can potentially be added as an
additional feature for the prototype.
For example, a field \lstinline|dependentObjects.externalHttpRef| could be added,
with the logic for calling HTTP/S URIs, and parsing the result.

\subsection*{Objective 4}

The requirement 1 of objective 4 (OBJ4R1) was the following:

\begin{quotation}
	\noindent
	\ref{OBJ4R1}
\end{quotation}

The developed prototype GitOps Promotions Operator supports the use of GitHub currently,
however the custom resource API is designed with a generic specification and therefore allows
for adding the support for any other Git provider in the future.
The same vendor-neutral approach was chosen for the GitOps engine.
These are most often from the Flux or Argo projects.
The GitOps Promotions Operator prototype allows the use of any GitOps engine,
because it interfaces only with Kubernetes built-in resources at this point.
Furthermore, the prototype is agnostic to the configuration/templating tool which may be used or not.
This is most prominently Helm and Kustomize. Since the operator provides the ability
to promote arbitrary files or directories in Git repositories, it is not needed to specifically integrate
with the named tools.






\section{Summary}

TODO






%\chapter{Interviews with Working Professionals}
%
%\section{Categorisation of Findings}
%\section{Common Problem Definitions}
%\section{...?}
%
%
%\chapter{Definition of Solution Objectives}
%
%\section{People \& Communication Perspective}
%\section{Technical Perspective}
%\section{...?}
%
%
%\chapter{Prototype Design and Development}
%
%\section{Architecture}
%\section{Functionality}
%\section{...?}
%
%\chapter{Proof-of-Concept Demonstration}
%
%\section{Setup and Use with Kustomize}
%\section{Setup and Use with Helm}
%\section{Multiple Environments in same Stage}
%\section{Scalability}
%\section{...?}















%
%\section{Instruction included in the original FHBgld word processor template}
%Die Durchführung der empirischen Untersuchung ist nachvollziehbar zu dokumentieren sowie auch die dabei aufgetretenen Probleme und deren Behandlung. Der Umfang ergibt sich aus der Art der Bearbeitung.  
%
%Tabelle 1 zeigt ein Bespiel für eine Tabelle. 
%
%\begin{figure}[ht]
%	\centering
%	\includegraphics[width=0.7\linewidth]{figures/Word_Table}
%	\caption{Screenshot example from FHBgld word processor template}
%	\label{fig:wordtable}
%\end{figure}
%Abbildung 1 zeigt ein Beispiel für eine Abbildung oder Grafik.
%\begin{figure}
%	\centering
%	\includegraphics[width=0.7\linewidth]{figures/Word_Diagram}
%	\caption{Screenshot example from FHBgld word processor template}
%	\label{fig:worddiagram}
%\end{figure}
%\linebreak
%Mathematisch werden die Zusammenhänge wie im Figure \ref{fig:wordformel} beschrieben.
%\begin{figure}
%	\centering
%	\includegraphics[width=0.7\linewidth]{figures/Word_Formel}
%	\caption{Screenshot example from FHBgld word processor template}
%	\label{fig:wordformel}
%\end{figure}
%
%\section{Tables and Images with \LaTeX}
%One of the great advantages of \LaTeX{} is that all it needs to know is
%the structure of a document, and then it will take care of the layout
%and presentation itself.  So, here we shall begin looking at how exactly
%you tell \LaTeX{} what it needs to know about your document.
%
%\subsection{Tables}
%In this sub-section, a simple table is inserted. To add reference to the table, see (cf. Table~\hyperref[tab:tableexample0]{\ref{tab:tableexample0}}):
%
%%A simple table.  The center environment is first set up, otherwise the
%%table is left aligned.  The tabular environment is what tells Latex
%%that the data within is data for the table.
%% https://en.wikibooks.org/wiki/LaTeX/Tables
%\begin{table}[htb]
%	\begin{tabular}{|b{7cm}|c|}
%		%The tabular environment is what tells Latex that the data within is
%		%data for the table.  The arguments say that there will be two
%		%columns, both left justified (indicated by the 'l', you could also
%		%have 'c' or 'r'.  The bars '|' indicate vertical lines throughout
%		%the table.
%		
%		\hline  % Print horizontal line
%		\fontsize{11pt}{12pt}\selectfont Command & Level \\ \hline  % Columns are delimited by '&'.  And
%		%rows are delimited by '\\'
%		\fontsize{10pt}{14pt}\selectfont Some sections to provide some examples: & \\
%		\texttt{\textbackslash part\{\emph{part}\}} & -1 \\
%		\texttt{\textbackslash chapter\{\emph{chapter}\}} & 0 \\
%		\texttt{\textbackslash section\{\emph{section}\}} & 1 \\
%		\texttt{\textbackslash subsection\{\emph{subsection}\}} & 2 \\
%		\texttt{\textbackslash subsubsection\{\emph{subsubsection}\}} & 3 \\
%		\texttt{\textbackslash paragraph\{\emph{paragraph}\}} & 4 \\
%		\texttt{\textbackslash subparagraph\{\emph{subparagraph}\}} & 5 \\
%		\hline
%		
%	\end{tabular}
%	\caption{some description of the table}
%	\label{tab:tableexample0}
%\end{table}
%
%\subsubsection{More tabular examples}
%
%First, a plain simple example for a FHBgld table, see table~\hyperref[tab:tab:tableexample1]{\ref{tab:tableexample1}}.
%
%\begin{table}[h]
%	\centering
%	\begin{tabular}{|b{1cm}|b{2cm}|b{3cm}|b{4cm}|}
%		\hline
%		\multicolumn{4}{|l|}{\fontsize{11pt}{12pt}\selectfont\noindent First line in 11pt fontsize } \\ \hline
%		1cm & 2cm & 3cm & 4cm \\ \hline
%		from & here on & the table & font size \\ \hline
%		will & be as & defined & in class, that is 10pt\footnote{yes, really!} \\ \hline
%		will & be as & defined & in class, that is 10pt\footnote{yes, really!} \\ \hline
%		will & be as & defined & in class, that is 10pt\footnote{yes, really!} \\ \hline
%		will & be as & defined & in class, that is 10pt\footnote{yes, really!} \\ \hline
%		will & be as & defined & in class, that is 10pt\footnote{yes, really!} \\ \hline
%	\end{tabular}
%	\caption{some description of the table}
%\label{tab:tableexample1}
%\end{table}
%
%Next, a table with nine columns, see table~\hyperref[tab:tableexample2]{\ref{tab:tableexample2}}.
%
%\begin{table}[h]
%	\centering
%	\begin{tabular}{|*{9}{l|}}
%		\hline
%		{\fontsize{11pt}{12pt}\selectfont This} & {\fontsize{11pt}{12pt}\selectfont table} & {\fontsize{11pt}{12pt}\selectfont has} & {\fontsize{11pt}{12pt}\selectfont way} & {\fontsize{11pt}{12pt}\selectfont too } & {\fontsize{11pt}{12pt}\selectfont many} & {\fontsize{11pt}{12pt}\selectfont columns}, & {\fontsize{11pt}{12pt}\selectfont does'nt} & {\fontsize{11pt}{12pt}\selectfont it?} \\ \hline
%		One & Two & Three & Four & Five & Six & Seven & Eight & Nine! \\ \hline
%		At & least & the & first & column & has & 11pt & font & size. \\ \hline
%	\end{tabular}
%	\caption{some description of the table}
%	\label{tab:tableexample2}
%\end{table}
%
%\subsection{Images}
%% Here is how to insert an image as a figure. There is a lot more you can do
%% when inserting images, check out: https://en.wikibooks.org/wiki/LaTeX/Importing_Graphics
%
%\begin{figure}[h]
%	\centering
%	\includegraphics[width=0.3\textwidth]{figures/logo_nontransparent.jpg}
%	\caption{Image Example}
%	\label{fig:image_example}
%\end{figure}
%
%When an image is inserted, you can refer to it like this (cf. Figure~\hyperref[fig:image_example]{\ref{fig:image_example}}).
%
%\subsubsection{A Subsubsection}
%As one last example, this is how you can insert a sub-sub-section! Have fun
%writing your thesis with \LaTeX{}!
%
%\lipsum[2-3]
%\raggedbottom
%
%\pagebreak
